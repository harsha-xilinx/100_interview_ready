üß© RTL Design Project List ‚Äî Verilog Practice (2-Year Level)

‚∏ª

üîπ 1Ô∏è‚É£ Basic Sequential & Combinational Logic

1. Priority Arbiter (4-way)
	‚Ä¢	Module: priority_arbiter.v
	‚Ä¢	Inputs: req[3:0]
	‚Ä¢	Output: grant[3:0] (one-hot)
	‚Ä¢	Goal: Learn combinational arbitration logic, priority encoding.
	‚Ä¢	Testbench: Random req patterns, check only one grant active and priority respected.

‚∏ª

2. Up/Down Counter (Parameterized)
	‚Ä¢	Module: up_down_counter.v
	‚Ä¢	Inputs: clk, rst_n, en, dir
	‚Ä¢	Output: count[N-1:0]
	‚Ä¢	Goal: Synchronous enable/disable, up-down direction, wrap-around vs saturation.
	‚Ä¢	Testbench: Toggle direction mid-count, apply enable gating.

‚∏ª

3. Sequence Detector (FSM)
	‚Ä¢	Module: seq_detector_1011.v
	‚Ä¢	Inputs: clk, rst_n, in_bit
	‚Ä¢	Output: detect
	‚Ä¢	Goal: Build Mealy FSM that detects ‚Äú1011‚Äù in a serial bitstream.
	‚Ä¢	Testbench: Apply overlapping patterns (e.g., 1011011).

‚∏ª

‚∏ª

‚è± 2Ô∏è‚É£ Pipelining & Throughput Optimization

4. 3-Stage Pipelined Multiplier
	‚Ä¢	Module: pipelined_multiplier.v
	‚Ä¢	Inputs: clk, rst_n, a[15:0], b[15:0]
	‚Ä¢	Output: product[31:0]
	‚Ä¢	Goal: Learn latency, valid signal tracking across stages.
	‚Ä¢	Testbench: Issue new operands every clock, verify delayed output.

‚∏ª

5. Parameterized Pipeline Register
	‚Ä¢	Module: pipeline_register.v
	‚Ä¢	Inputs: clk, rst_n, din[W-1:0]
	‚Ä¢	Output: dout[W-1:0]
	‚Ä¢	Parameter: DEPTH
	‚Ä¢	Goal: Implement configurable register pipeline using generate loop.
	‚Ä¢	Testbench: Verify for DEPTH = 0, 1, 3.

‚∏ª

6. Synchronous FIFO
	‚Ä¢	Module: sync_fifo.v
	‚Ä¢	Inputs: clk, rst_n, wr_en, rd_en, din[W-1:0]
	‚Ä¢	Outputs: dout[W-1:0], full, empty
	‚Ä¢	Goal: Pointer-based FIFO, no combinational feedback.
	‚Ä¢	Testbench: Random write/read pattern with boundary conditions.

‚∏ª

‚∏ª

üß† 3Ô∏è‚É£ FSM & Control Design

7. Elevator Controller (4 Floors)
	‚Ä¢	Module: elevator_ctrl.v
	‚Ä¢	Inputs: clk, rst_n, req[3:0]
	‚Ä¢	Outputs: floor[1:0], dir_up
	‚Ä¢	Goal: FSM scheduling, priority logic, directional continuity.
	‚Ä¢	Testbench: Generate random requests, check movement sequence.

‚∏ª

8. UART Transmitter
	‚Ä¢	Module: uart_tx.v
	‚Ä¢	Inputs: clk, rst_n, tx_start, tx_data[7:0]
	‚Ä¢	Outputs: tx_out, tx_busy
	‚Ä¢	Goal: Design bit timing logic (1 start, 8 data, 1 stop).
	‚Ä¢	Testbench: Compare output serial waveform to expected frame.

‚∏ª

9. Traffic Light Controller
	‚Ä¢	Module: traffic_light_ctrl.v
	‚Ä¢	Inputs: clk, rst_n, sensor_main, sensor_side
	‚Ä¢	Outputs: light_main[2:0], light_side[2:0]
	‚Ä¢	Goal: FSM with timing counters, sensor-based preemption.
	‚Ä¢	Testbench: Toggle sensors at random times, ensure safety rules (no both green).

‚∏ª

‚∏ª

üîÑ 4Ô∏è‚É£ CDC (Clock Domain Crossing)

10. 2-FF Synchronizer
	‚Ä¢	Module: sync_2ff.v
	‚Ä¢	Inputs: clk_dst, rst_n, async_in
	‚Ä¢	Outputs: sync_out
	‚Ä¢	Goal: Understand metastability isolation and latency.
	‚Ä¢	Testbench: Simulate async pulses with two different clocks.

‚∏ª

11. REQ/ACK Handshake Synchronizer
	‚Ä¢	Module: handshake_sync.v
	‚Ä¢	Inputs: clk_a, clk_b, event_a
	‚Ä¢	Output: pulse_b
	‚Ä¢	Goal: Safe event transfer with two-way handshake.
	‚Ä¢	Testbench: Generate multiple async events at random intervals.

‚∏ª

12. Asynchronous FIFO
	‚Ä¢	Module: async_fifo.v
	‚Ä¢	Inputs: wr_clk, rd_clk, wr_en, rd_en, din[7:0]
	‚Ä¢	Outputs: dout[7:0], full, empty
	‚Ä¢	Goal: Gray-coded pointers, dual clock domain CDC.
	‚Ä¢	Testbench: Randomize clock ratios (e.g., 1:3, 2:5), verify data integrity.

‚∏ª

‚∏ª

‚ö° 5Ô∏è‚É£ Interface & Bus Protocols

13. AXI4-Lite Slave
	‚Ä¢	Module: axi_lite_slave.v
	‚Ä¢	Inputs: Standard AXI signals
(AWADDR, WVALID, WDATA, etc.)
	‚Ä¢	Goal: Handle address phase, data phase, response.
	‚Ä¢	Testbench: Use AXI master TB that writes & reads back registers.

‚∏ª

14. APB to AXI-Lite Bridge
	‚Ä¢	Module: apb2axi_bridge.v
	‚Ä¢	Goal: Convert single APB transaction into AXI-Lite transfer.
	‚Ä¢	Testbench: Drive APB writes and verify AXI handshakes.

‚∏ª

15. AXI Stream Width Converter (32‚Üí64 bits)
	‚Ä¢	Module: axi_stream_width_conv.v
	‚Ä¢	Inputs: s_axis_tdata[31:0], s_axis_tvalid
	‚Ä¢	Outputs: m_axis_tdata[63:0], m_axis_tvalid
	‚Ä¢	Goal: Aggregate two input beats into one output beat.
	‚Ä¢	Testbench: Feed multiple packets, verify correct packing.

‚∏ª

‚∏ª

üßÆ 6Ô∏è‚É£ Arithmetic & DSP

16. Signed Multiplier with Overflow
	‚Ä¢	Module: signed_mult.v
	‚Ä¢	Inputs: clk, a[15:0], b[15:0]
	‚Ä¢	Outputs: result[31:0], overflow
	‚Ä¢	Goal: Implement signed multiplication and detect overflow.
	‚Ä¢	Testbench: Random operands, edge cases (¬±32768 √ó 2).

‚∏ª

17. 4-Tap FIR Filter
	‚Ä¢	Module: fir_filter.v
	‚Ä¢	Inputs: clk, rst_n, data_in
	‚Ä¢	Outputs: data_out
	‚Ä¢	Parameters: coefficients
	‚Ä¢	Goal: Implement MAC structure (shift register + multiply + sum).
	‚Ä¢	Testbench: Apply impulse input; verify impulse response = coefficients.

‚∏ª

18. Fixed-Point Divider (Restoring Algorithm)
	‚Ä¢	Module: fixed_div.v
	‚Ä¢	Inputs: clk, rst_n, start, dividend, divisor
	‚Ä¢	Outputs: quotient, remainder, done
	‚Ä¢	Goal: Iterative division using FSM and shift/subtract logic.
	‚Ä¢	Testbench: Verify multiple divisions with edge cases (divide by 0).

‚∏ª

‚∏ª

üß± 7Ô∏è‚É£ Low-Power & DFT

19. Clock Gating Cell
	‚Ä¢	Module: clock_gater.v
	‚Ä¢	Inputs: clk_in, en
	‚Ä¢	Output: clk_gated
	‚Ä¢	Goal: Generate glitch-free gated clock (with latch-based enable).
	‚Ä¢	Testbench: Toggle enable around clock edges to ensure no glitches.

‚∏ª

20. Scan-Chain Register File
	‚Ä¢	Module: regfile_scan.v
	‚Ä¢	Inputs: clk, wr_en, rd_addr, wr_addr, wr_data, scan_en, scan_in
	‚Ä¢	Outputs: rd_data, scan_out
	‚Ä¢	Goal: 8x8 register file with scan chain for DFT.
	‚Ä¢	Testbench: Check normal and scan-shift operation.


üß† Tips for Each Project
	‚Ä¢	Use non-blocking (<=) for sequential always blocks.
	‚Ä¢	Add synchronous reset logic.
	‚Ä¢	Make all modules parameterized for width/depth.
	‚Ä¢	Add $monitor, $display, and waveform dumping ($dumpfile, $dumpvars) in TBs.
	‚Ä¢	Document latency, throughput, and critical path after synthesis.
	‚Ä¢	Use assertions to verify behavior (SystemVerilog assertions if supported).

‚∏ª

üèÅ Goal

By completing these 20 RTL modules + testbenches:
‚úÖ You‚Äôll cover FSM, datapaths, CDC, bus protocols, DSP, low power ‚Äî all key areas asked in interviews.
‚úÖ You‚Äôll have a portfolio you can show interviewers ‚Äî or link to your GitHub.
‚úÖ You‚Äôll be comfortable answering deep ‚Äúhow would you design‚Ä¶‚Äù questions.
